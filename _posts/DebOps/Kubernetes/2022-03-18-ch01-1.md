---
title:  "[KUBERNETES] 01. 컨테이너 오케스트레이션 (Container Orchestration)이란?" 

categories:
  - KUBERNETES
tags:
  - [kubernetes]

toc: true
toc_sticky: true

date: 2022-03-18
last_modified_at: 2022-03-18
---
# [KUBERNETES] 01. 컨테이너 오케스트레이션 (Container Orchestration)이란?
---

<style>
table {
    font-size: 12pt;
}
table th:first-of-type {
    width: 10%;
}
table th:nth-of-type(2) {
    width: 10%;
}
table th:nth-of-type(3) {
    width: 50%;
}
table th:nth-of-type(4) {
    width: 30%;
}
</style>

<br>

## 🔔 컨테이너 오케스트레이션 (Container Orchestration)이란?

> 컨테이너화된 애플리케이션을 효율적이고 빠르게 배포, 확장, 운영 및 관리 작업을 자동화하기 위해 설계된 플랫폼

![그림](https://user-images.githubusercontent.com/42735894/224530865-0fcc8bc8-d7bd-4380-b3c3-30d17e8314ba.png){: width="70%" height="70%"}{: .align-center}

> 쿠버네티스에서 실제 컨테이너가 기동하는 노드(호스트가 되는 물리 머신이나 가상 머신)는 쿠버네티스 노드라고 하고, 쿠버네티스 노드를 관리하는 노드는 쿠버네티스 마스터라 한다.

<br>

## 🔔 컨테이너를 서비스 환경에서 도입 시 해결해야할 과제 

|||
|:---:|:---:|
|여러 쿠버네티스 노드 관리|컨테이너 스케줄링|
|롤링 업데이트|스케일링/오토 스케일링|
|컨테이너 모니터링|자동화된 복구|
|서비스 디스커버리|로드 밸런싱|
|워크로드 관리|로그 관리|
|선언적 코드를 사용한 관리|그 외 에코 시스템과의 연계 및 확장|

> 이런 과제들은 컨테이너 오케스트레이션 엔진인 쿠버네티스등을 사용하면 자동화할 수 있거나 간단하게 오퍼레이션으로 해결할 수 있다. 

<br>

## 🔔 컨테이너 오케스트레이션 특징

<br>

### (a) 선언적 코드를 사용한 관리 (IaC)

> 쿠버네티스는 YAML, JSON 형식으로 작성한 선언적 코드(매니페스트)를 통해 배포하는 컨테이너로 주변 리소스를 관리할 수 있어 IaC를 구현할 수 있다.

<br>

### (b) 스케일링/오토 스케일링

> 쿠버네티스는 컨테이너 클러스터를 구성하여 여러 쿠버네티스 노드를 관리하며 컨테이너 이미지를 기반으로 여러 컨테이너를 배포하면 부하 분산 및 다중화 구조를 만들 수 있고 또한, 부하에 따라 컨테이너 레플리카 수를 자동으로 늘리거나 줄일(오토 스케일링) 수도 있다.

<br>

### (c) 스케줄링

> 컨테이너를 쿠버네티스 노드에 배포할 때 어떤 쿠버네티스 노드에 배포할 것인지를 결정하는 스케줄링 단계가 있고, 어피니티(Affinity)와 안티어피니티(Anti-Affinity) 기능을 통해 컨테이너화된 애플리케이션 워크로드의 특징이나 쿠버네티스 노드의 성능을 기준으로 스케줄링할 수 있다.

<br>

### (d) 자동화된 복구

> 쿠버네티스는 자동화된 복구 기능(Self-healing)을 제공하는데, 평소 컨테이너 프로세스를 모니터링하고 프로세스 정지를 감지하면 다시 컨테이너 스케줄링을 실행하여 컨테이너를 자동으로 재배포한다.<br><br>
클러스터 노드에 장애가 발생하거나 노드를 축출했을 경우 그 노드의 컨테이너가 사라진다 하더라도 서비스에 영향 없이 애플리케이션을 자동으로 복수할 수 있도록 되어 있고 자동화된 복구 실행 조건에는 프로세스 모니터링 외에 HTTP/TCP나 쉘 스크립트로 헬스 체크의 성공 여부를 설정할 수도 있다.

<br>

### (e) 로드밸런싱과 서비스 디스커버리

> 쿠버네티스는 로드밸런서 기능(서비스나 인그레스)을 제공하며, 사전에 정의한 조건과 일치하는 컨테이너 그룹에 라우팅하는 엔드포인트를 할당할 수 있고 컨테이너를 확장할 때 엔드포인트가 되는 서비스에 컨테이너의 자동 등록과 삭제, 컨테이너 장애 시 분리, 컨테이너 롤링 업데이트 시 필요한 사전 분리 작업도 자동으로 실행해준다. <br><br>
서비스 디스커버리 기능은 서비스를 찾아주는 기능으로 클러스터 환경에서 컨테이너 어느 서버에 생성될지 알 수 없기 때문에 컨테이너와 통신을 하기 위해 어느 서버에 실행 중인지 알려주고, 독립된 작은 규모의 애플리케이션을 연계하여 시스템을 구현하는 각각의 마이크로서비스가 서로의 마이크로서비스를 참조할 때 서비스 디스커버리 기능은 매우 유용하다.

<br>

### (f) 버전 관리 - 롤링 업데이트, 롤 아웃, 롤 백

> 컨테이너 배포작업은 개별 배포가 아닌 클러스터 전체를 대상으로 중앙에서 자동으로 진행될 수 있어야 하며, 이때 롤백과 롤 아웃 작업의 경우에도 중앙에서 관리하고 일괄적으로 다운 타임 없이 진행될 수 있어야 한다.<br><br>
롤링 업데이트는 새 버전을 배포하면서 새 버전 인스턴스를 하나씩 늘려가고 기존 버전의 인스턴스를 하나씩 줄여나가는 방식을 말하며, 이러한 경우 새 버전의 인스턴스로 트래픽이 이전되기 전까지 이전 버전과 새 버전의 인스턴스가 동시에 존재할 수 있다는 단점이 있지만, 시스템을 무중단으로 업데이트 할 수 있다는 장점이 있다.

<br>