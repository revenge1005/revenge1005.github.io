---
title:  "[가상화] 03. 전가상화와 반가상화" 

categories:
  - VIRTUALIZATION
tags:
  - [virtualization]

toc: true
toc_sticky: true

date: 2021-07-13
last_modified_at: 2021-07-13
---
# [가상화] 03. 전가상화와 반가상화
---

<style>
table {
    font-size: 12pt;
}
table th:first-of-type {
    width: 5%;
}
table th:nth-of-type(2) {
    width: 15%;
}
table th:nth-of-type(3) {
    width: 50%;
}
table th:nth-of-type(4) {
    width: 30%;
}
</style>

## 🔔 전가상화 (Full Virtualization)

![13213](https://user-images.githubusercontent.com/42735894/222969255-95df05bd-969e-43d1-a72f-12ce6a5a2e61.png){: width="100%" height="100%"}

> 전가상화란 **호스트 CPU의 가상화 기술을 통해 하드웨어를 완전히 가상화한다**는 의미로, 여기서 하드웨어를 **완전히 가상화한다는 것은 게스트OS가 자신이 가상 환경인지 모르는 상태를 의미**하며, 그에 따라 **실제 하드웨어에 명령을 직접 요청하는 것처럼 동작**한다.<br><br>
전가상화는 하드웨어를 에뮬레이팅하기 위해 **"이진 변환(Binary Translation)"** 방식을 사용한다.<br><br>
가상머신이 하드웨어를 제어하기 위해 하이퍼바이저에 바이너리 형태로 명령을 전달하게 되는데, 커널에서 하드웨어를 제어하는 과정에서 가상머신이 보낸 바이너리 형태의 명령을 바로 인식할 수 없기 때문에 해석하는 과정을 거치고 해석된 결과를 토대로 하드웨어를 제어하게 하는 과정이 "이진 변환(Binary Translation)"이다. <br><br>
하이퍼바이저를 실행하면 DOM0라는 관리용 가상머신이 실행되며, 전가상화는 모든 가상머신들의 하드웨어 접근 요청이 DOM0를 통해 이루어진다. <br><br>
즉, 각 운영체제마다 다른 명령의 표현 방식을 DOM0가 핸들링하여, 하드웨어가 이해할 수 있는 언어로 번역하고 최종적으로 하드웨어에 접근하는 이진 변환 과정을 거치게 된다.<br><br>
하드웨어를 완전히 가상화하기 때문에 게스트 OS와 커널을 수정할 필요 없이 바로 사용이 가능하다는 장점이 있으나, 모든 명령이 DOM0를 거치기 때문에 반가상화 방식에 비해 비교적 느리다.

<br>

## 🔔 반가상화 (Para Virtualization)

![3123213123](https://user-images.githubusercontent.com/42735894/222969426-3ff8ffc7-d220-4cb1-99a3-1734387ea8d1.png){: width="100%" height="100%"}

> 반가상화는 **전가상화와 달리 하드웨어를 완전히 가상화하지 않기 때문에 게스트 OS는 스스로 가상화된 환경임을 인지하고 있으며, 하이퍼바이저가 하드웨어를 제어하기 때문에 성능의 불이익이 없이 가상화를 할 수 있다.**<br><br>
반가상화의 경우, 하이퍼바이저가 하드웨어를 직접 제어할 수 있는 API를 제공하고, **게스트 OS의 수정된 커널이 하이퍼바어저의 API를 통해 하드웨어 자원에 접근하는 특권 명령/작업을 수행**하며, 이렇게 **수정된 게스트 OS 커널이 직접 시스템 콜을 하는 방식을 "하이퍼 콜(Hyper Call)"**이라고 부른다. <br><br>
반가상화 하이퍼바이저의 경우 게스트 OS가 수정된 커널을 사용해야 한다는 단점이 있으나, 전가상화에 비해 중간에 이진 변환하는 **에뮬레이트 절차가 없기 때문에 상대적으로 성능 오버헤드가 적다.**

<br>

## 🔔 하드웨어 자원 가상화

> 인텔과 AMD CPU에서는 하드웨어 단에서 가상화 기능을 제공하는데 이러한 가상화 기능을 각각 **VT-x(인텔)과 AMD-V(AMD)**라고 부른다.<br><br>
둘 다 x86 기반 아키텍처에서 동작하며, 해당 아키텍처에서 동작하는 가상머신이 하드웨어를 직접 제어할 수 있는 인스트럭션을 제공하고 이에 따라 전가상화 하이퍼바이저 기반의 VM도 Ring 0에서 동작하는 효과를 볼 수 있다.<br><br>
이러한 하드웨어 가상화 지원 방식을 사용하는 소프트웨어로 KVM을 예로 들 수 있으며, 하드웨어가 자체적으로 가상화를 지원하지 않는다면 KVM과 같은 모듈을 사용할 수 없다.

<br>

## 🔔 전가상화와 반가상화 하드웨어 제어 방식

- 운영체제에서 구동되는 소프트웨어는 보안을 위해 권한과 보호 수준에 따른 링(Ring) 등급으로 나누어진다.

|구분|설명|
|:---:|---|
|Ring 0|"특권 모드"라고 하며 시스템 자원을 관리하느 OS 커널이 동작|
|Ring 1, 2|장치 드라이버 또는 예약된 상태로, 평상시에는 사용 안함|
|Ring 3|우리가 일반적으로 사용하는 응용프로그램들이 동작|

### (1) Trap & Emulate

> 전가상화를 하면 "Root 모드", "Non-root 모드"가 생기게 되는데, 이때 **하이퍼바이저가 "Root 모드", 운영체제 및 애플리케이션이 "Non-root 모드"에 해당**한다.<br><br>
이러한 구조에서 만약 게스트 OS가 하드웨어에 접근하기 위해 특권 명령을 처리해야 하는 상황이 오면 전가상화는 **"Trap & Emulate 방식"**으로 처리한다. <br><br>
**Trap이란 특권 명령을 실행할 권한이 없는 비특권 모드(게스트 OS)에서 특권 명령을 실행할 시스템에 발생하는 예외 또는 결함**을 말한다.<br><br>
예를 들어 0으로 나누기나 디버깅을 위한 중단점과 같은 처리를 하면 프로그램의 제어권이 Trap 사건을 처리하는 트랩 핸들러로 넘어가게 된다.

![ㅇㅁㄴㅇㅁㄴㅇㅁ](https://user-images.githubusercontent.com/42735894/222969728-41034b1c-0d2d-430a-b54b-63cd985619c1.png){: width="100%" height="100%"}

|동작 순서|내용|
|:---:|---|
|(1)|비특권 모드인 게스트 OS에서 특권 명령을 수행하려고 한다.|
|(2)|게스트 OS는 트랩 상태로 바뀌고, 트랩 핸들러는 VM exit을 통해 제어권을 하이퍼바이저로 넘겨준다.|
|(3)|하이퍼바이저는 해당 명령을 처리한다. (Emulate)|
|(4)|해당 명령의 처리가 끝나면 VM Enter를 통해 실행결과와 함께 제어권을 운영체제로 넘겨준다.|

> 하지만 "Trap & Emulate 방식"은 **호환성을 확실하게 보장할 수 있는 방법이지만 트랩이라는 이벤트가 발생하여 게스트 OS의 실행이 중단되는 등 그 자체로 시스템 오버헤드가 상당히 크며, "Trap & Emulate 방식"만으로 하이퍼바이저를 구현하는 것은 어렵다고 한다.**<br><br>
이러한 문제를 극복하고자 VMware에서는 "이진 변환(Binary Translation)" 이란 기술을 선보였다.

### (2) 이진 변환 (Binary Translation)

> 이진 변환이란 **게스트 OS에서 특권 명령을 수행하려고 할 때 하이퍼바이저가 바이너리 연산을 통해 하드웨어가 인식할 수 있는 명령어로 변환하여 전달하는 기법**이다.<br><br>
**CPU에서 직접 실행하는 방식이지만 중간에 하이퍼바이저가 번역하는 과정이 추가되었고 이러한 방법은 개발하기 상당히 까다롭다는 단점**이 있었다.

### (3) Hyper Call

![ㅇㅁㅇㄴㅇㄴㅁ](https://user-images.githubusercontent.com/42735894/222970057-1b66b2a5-71ad-403a-b494-cf92cd95272b.png){: width="100%" height="100%"}

> Xen에서는 전가상화의 성능적인 문제점을 해결하기 위해 고안된 기술로, "하이퍼 콜(Hyper Call)"이라는 방법을 제안하였는데, 반가상화라는 대비되는 명칭을 갖게 되었다.<br><br>
**OS의 커널을 일부 수정하고 하이퍼 콜이라는 인터페이스를 통해 OS 자체에서 명령을 번역해서 보내는 방식으로 하이퍼바이저가 모든 게스트 OS의 명령을 해석하는 과정을 거치지 않아 성능적으로 좋다.**<br><br>
하지만 **OS에서는 기본적으로 하이퍼 콜에 대한 기능이 없기 때문에 커널을 직접 수정해야 했지만 최근에는 OS에서 내장된 상태로 존재하여 번거로움이 없다고 한다.**