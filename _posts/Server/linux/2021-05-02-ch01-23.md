---
title:  "[Linux 기초] 23. 디스크 관리 - RAID" 

categories:
  - LINUX
tags:
  - [linux]

toc: true
toc_sticky: true

date: 2021-05-02
last_modified_at: 2021-05-02
---
<br>

# 01. RAID(Redundant Array of Independent Disks)
---

<style>
table {
    font-size: 12pt;
}
table th:first-of-type {
    width: 5%;
}
table th:nth-of-type(2) {
    width: 15%;
}
table th:nth-of-type(3) {
    width: 50%;
}
table th:nth-of-type(4) {
    width: 30%;
}
big {
    font-size: 15pt;
}
</style>

> 여러 개의 디스크를 하나로 묶어서 고성능이나 고용량, 또는 안정성을 향상시키기 위한 기술

<br>

## 1) RAID 0 ( Concatenation & Stripe )

+ 최소 디스크 개수 : 2

<br>

![raid-0 - 복사본](https://user-images.githubusercontent.com/42735894/233989769-1a7bb0bb-502a-49d9-b39b-906d95f59582.png){: width="70%" height="70%"}{: .align-center}

<br>

<big> **■ RAID 0 - Concatenation** </big>

+ 2개 이상의 디스크를 직렬로 묶어 하나의 큰 논리적 드라이브로 만들고 데이터를 순차적으로 저장하는 방식

+ 첫 번째 디스크에 데이터가 꽉 차면 두 번째 디스크로 넘어가고, 그 다음 디스크로 넘어가는 식으로 데이터가 분산한다.

+ **장점**

    |장점|설명|
    |:---:|:---|
    |용량 확장|여러 개의 드라이브를 하나의 가상 드라이브로 연결하여 사용하므로, 드라이브를 추가하면 전체적인 용량이 확장될 수 있다.|

+ **단점**

    |단점|설명|
    |:---:|:---|
    |안정성 감소|RAID 0의 특성상 데이터를 순차적으로 저장하기 때문에, 하나의 드라이브가 고장 나면 해당 드라이브에 저장된 데이터 전체가 손실|
    |공간 활용성 감소|여러 개의 드라이브를 연결하여 사용하므로, 각 드라이브의 남은 공간이 다 차기 전까지 전체적인 공간 활용성이 감소|


<br>

<big> **■ RAID 0 - Stripe** </big>

+ 2개 이상의 디스크를 병렬로 묶어 하나의 큰 논리적 드라이브로 만들고 디스크에 데이터를 여러 개의 디스크에 나누어 저장하는 방식

+ A,B 라는 디스크를 Stripe로 연결했고 "1234"라는 데이터를 저장한다고 가정할 때, "1" 데이터는 A 디스크, "2" 데이터는 B 디스크, "3" 데이터는 A 디스크, "4" 데이터는 B 디스크 식으로 데이터가 분산된다.

+ **장점**

    |장점|설명|
    |:---:|:---|
    |성능 향상|데이터를 병렬로 분산하여 저장하므로, 전체적인 입/출력 성능이 향상될 수 있다.|
    |공간 활용성 향상|데이터를 블록 단위로 분산하여 저장하므로, 각 드라이브의 남은 공간을 최대한 활용할 수 있다.|
    
+ **단점**

    |단점|설명|
    |:---:|:---|
    |용량이 같아야 함|드라이브를 추가하려면 모든 드라이브에 동일한 크기의 드라이브를 추가해야 하며함|
    |용량 확장|데이터를 블록 단위로 분산하여 저장하기 때문에, 기존 데이터를 다시 재구성해야 합니다.|
    |안정성 감소|Concatenation과 마찬가지로, 하나의 드라이브가 고장 날 경우 해당 블록에 저장된 데이터가 손실|
    |복구 어려움|데이터가 여러 개의 드라이브에 분산되어 저장되기 때문에, 고장 난 드라이브의 데이터를 복구하려면 모든 드라이브의 데이터를 참조해야 할 수 있어 복구 작업이 복잡해질 수 있다.|

<br>

## 2) RAID 1 ( Mirroring )

+ 최소 디스크 개수 : 2

+ 2개 이상의 동일한 용량을 가진 디스크를 사용하여 데이터를 복제하는 방식 

+ 즉, 데이터를 동일한 내용으로 복사하여 여러 개의 드라이브에 저장하는 방식으로, 모든 드라이브에 동일한 데이터가 저장됨

<br>

![raid-1](https://user-images.githubusercontent.com/42735894/233989776-c06b52d3-a33f-42b9-a746-7b641afc0606.png){: width="70%" height="70%"}{: .align-center}

<br>

+ **장점**

    |장점|설명|
    |:---:|:---|
    |안정성 높음|데이터를 복제하여 여러 개의 드라이브에 저장하기 때문에 한 드라이브에 장애가 발생하더라도 다른 드라이브에 데이터가 남아있어 데이터의 안정성이 높다.|
    
+ **단점**

    |단점|설명|
    |:---:|:---|
    |용량 효율성이 낮음|데이터를 복제하여 저장하기 때문에 용량 효율성이 낮음|

<br>

## 3) RAID 5 

+ 최소 드라이버 개수 : 3

+ 3개 이상의 디스크를 사용하여 데이터와 패리티 정보를 분산 저장하는 방식

+ 패리티 정보는 데이터의 오류 검출과 복구에 사용되며, 한 디스크가 고장나도 다른 디스크에서 패리티 정보를 이용해 데이터를 복구할 수 있다.

+ 패리티 블록은 데이터 블록들의 XOR 연산 결과로 계산되어 저장되어, 데이터 블록의 손상 시에 복구를 가능하게 한다.

+ 1개의 디스크에 에러 발생할 경우에는 복구가가 가능하지만 2개 이상은 불가능하다.

<br>

![raid-5](https://user-images.githubusercontent.com/42735894/233989784-a59af0cd-d15d-44b2-9a6b-20024cb404e5.png){: width="70%" height="70%"}{: .align-center}

<br>

+ **장점**

    |장점|설명|
    |:---:|:---|
    |안정성이 높음|패리티 정보를 사용하여 데이터의 손상을 복구할 수 있어, 한 개의 드라이브에 장애가 발생하더라도 데이터의 안정성을 보장|
    
+ **단점**

    |단점|설명|
    |:---:|:---|
    |패리티 오버헤드|패리티 정보를 계산하고 저장하는 오버헤드가 존재하며, 데이터를 쓸 때마다 패리티 정보를 계산하고 저장해야 하므로, 쓰기 성능에 영향을 미칠 수 있다.|
    |복구시간|패리티 정보를 이용하여 복구을 진행하면 해당 패리티 정보와 관련된 데이터 블록들을 참조하여 데이터를 복구해야 하기 때문에, 복구 시간이 오래 걸릴 수 있다.|

<br>

## 4) RAID 6

+ 최소 드라이버 개수 : 4

+ RAID 5와 유사한 구조이지만 패러티(Parity)를 하나 더 가지는 구조

+ 이중 패리티 정보를 사용하기 때문에 RAID 6은 2개의 디스크 드라이브 동시 고장에도 내구성을 유지할 수 있다.

<br>

![raid-6](https://user-images.githubusercontent.com/42735894/233989789-32ac77cd-00c2-4889-9d12-7723d0a726a3.png){: width="70%" height="70%"}{: .align-center}

<br>

+ **장점**

    |장점|설명|
    |:---:|:---|
    |안정성이 높음|RAID 5보다 더 높은 데이터의 안정성과 가용성을 제공, 두 개의 디스크가 동시에 고장나도 데이터를 잃지 않는다|
    
+ **단점**

    |단점|설명|
    |:---:|:---|
    |추가적인 저장 공간|RAID 5보다 더 많은 디스크가 필요,  최소 4개 이상의 디스크가 필요하며, 2개의 디스크 용량만큼이 패리티 정보로 사용되기 때문에 실제 사용할 수 있는 용량이 줄어든다.|
    |패리티 오버헤드|RAID 5보다 더 많은 연산이 필요, 패리티 정보를 두 번 계산하고 저장해야 하기 때문에 속도가 저하될 수 있다.|

<br>

## 4) RAID 1+0, RAID 0+1

+ 최소 드라이버 개수 : 4

+ RAID 1 (미러링)과 RAID 0 (스트라이핑)을 조합한 구성

<br>

![다운로드 (1)](https://user-images.githubusercontent.com/42735894/233989792-0ab147b4-781d-4e97-8fc9-e6d1c5406839.jpg){: width="70%" height="70%"}{: .align-center}

<br>

<big> **■ RAID 1+0** </big>

+ 먼저 데이터를 미러링하여 중복 저장하고, 그 다음에 스트라이핑을 적용 즉, 데이터를 복제하고 그 복제된 데이터를 스트라이핑 방식으로 저장하는 방식

+ 데이터를 두 개 이상의 디스크에 복제하여 저장하고, 그 복제된 데이터를 스트라이핑 방식으로 나머지 디스크 드라이브에 저장한다.

+ 예를 들면, 4개의 디스크가 있을 경우, 2개의 디스크를 미러링하여 데이터를 저장하고, 그 미러링된 데이터를 나머지 2개의 디스크에 스트라이핑 방식으로 저장한다.

<br>

<big> **■ RAID 0+1** </big>

+ 먼저 데이터를 스트라이핑 방식으로 저장하고, 그 다음에 미러링을 적용 즉, 데이터를 스트라이핑 방식으로 저장하고 그 스트라이핑된 데이터를 복제하여 저장하는 방식

+ 데이터를 스트라이핑 방식으로 여러 디스크에 나누어 저장하고, 그 스트라이핑된 데이터를 미러링하여 나머지 디스크에 복제하여 저장한다.

+ 예를 들면, 4개의 디스크가 있을 경우, 2개의 디스크에 스트라이핑 방식으로 데이터를 저장하고, 그 스트라이핑된 데이터를 다른 2개의 디스크에 복제하여 저장한다.