---
title:  "[Cloud] 10. 메모리 가상화" 

categories:
  - CLOUD
tags:
  - [Cloud]

toc: true
toc_sticky: true

date: 2023-11-29
last_modified_at: 2023-11-29
---
<br>

# 01. 메모리 가상화
---

<style>
table {
    font-size: 12pt;
}
table th:first-of-type {
    width: 5%;
}
table th:nth-of-type(2) {
    width: 15%;
}
table th:nth-of-type(3) {
    width: 50%;
}
table th:nth-of-type(4) {
    width: 30%;
}
big {
    font-size: 15pt;
}
small { 
    font-size: 18px 
}
</style>

> **"메모리 가상화는 시스템의 메모리를 가상화하는 것으로 실제 물리시스템의 메모리가 관리되는 방식을 가상화해야 한다. 물리시스템은 운영체제에서 가상메모리 기법을 통해서 메모리를 관리하는데 <U>즉, 메모리를 가상화하기 위해서는 가상메모리를 가상화해야 한다는 결론을 얻게 된다.</U>"**

<br>

<big> **■ 가상메모리** </big> <br>

<div style="display: flex; justify-content: space-between;">
    <div style="width: 60%; padding-right: 10px;">
        가상메모리는 메모리 관리 기법의 하나로, <span style="color:red"><b>실제 시스템에 장착된 물리메모리를 주소 공간의 크기만큼 관리할 수 있는 기법</b></span>이다. <br><br> 예를 들어 64비트 시스템이 가질 수 있는 주소 공간은 2^64개의 메모리의 위치를 가리킬 수 있다. 메모리는 바이트 단위로 관리하기 때문에 총 메모리 공간은 2^64=16EB까지 메모리 공간을 활용할 수 있다. <U>즉, 실제 물리 메모리가 주소 공간만큼 존재하지 않더라도 가상메모리 기법을 사용하여 마치 가상적으로 메모리가 존재하는 것처럼 만들 수 있다.</U> <br><br> <U>메모리는 페이지(page) 단위로 관리</U>되며, 메모리 공간이 부족할 경우 보조 기억장치(예: 하드디스크)를 이용하여 물리메모리 공간보다 큰 공간을 사용할 수 있게 해해준다. 이를 통해 운영체제는 물리적으로 제한된 메모리보다 더 큰 메모리 공간을 효율적으로 활용하며, 이는 애플리케이션의 성능 향상에 기여한다.
    </div>
    <div style="width: 40%; display: flex; justify-content: center; align-items: center;">
        <img src="https://github.com/revenge1005/WEB-Server-3-Tier-Architecture/assets/42735894/f8016e10-29e0-4d56-a339-a69f596d4f77" alt="Virtual_memory svg" style="width: 60%;">
    </div>
</div>

<br><br>

<div style="display: flex; justify-content: space-between;">
    <div style="width: 60%; padding-right: 10px;">
        <U>MMU(Memory Management Unit)은 컴퓨터 시스템에서 가상 메모리 주소를 물리 메모리 주소로 변환하는 역할</U>을 하는 하드웨어 장치이다. <br><br> 예를 들면, 책을 읽을 때 책갈피를 사용하는 것과 비슷하다. 책갈피를 통해 우리는 바로 원하는 페이지를 찾아갈 수 있는 것처럼 MMU도 프로그램이 사용하는 가상 주소를 실제 물리 메모리 주소로 변환해주는 <U>일종의 '주소 책갈피' 역할</U>을 한다. <br><br> 이렇게 하면 프로그램은 실제 메모리 주소를 걱정하지 않고, 자신만의 가상 메모리 공간에서 작동할 수 있다. 이 과정을 통해 운영 체제는 메모리를 효율적으로 관리하고, 프로그램 간 메모리 충돌을 방지할 수 있다.
    </div>
    <div style="width: 40%; display: flex; justify-content: center; align-items: center;">
        <img src="https://github.com/revenge1005/WEB-Server-3-Tier-Architecture/assets/42735894/90ea0ae8-9791-44b4-b18c-3e4f48ca2660" alt="mmu" style="width: 100%;">
    </div>
</div>

<br><br>

<div style="display: flex; justify-content: space-between;">
    <div style="width: 60%; padding-right: 10px;">
        MMU는 요청받은 가상 주소에 매핑되는 물리 주소를 가져올 때 이전에 가져온 적이 있는지를 확인하는데, <U>이전에 가상 주소와 물리 주소 간 매핑 정보를 가지고 있는 것이 TLB(table lookaside buffer)</U>이다. 즉, TLB는 캐시 역할을수행하여 좀 더 빠르게 가상 주소를 물리 주소로 변환해주는 역할을 한다. <br><br><U>만약 해당 가상 주소에 해당하는 물리 주소가 존재하지 않는다면, '페이지 테이블(page table)'을 통해서 해당 물리 주소를 반환</U>한다. TLB에 해당 물리 주소가 '존재하지 않는 경우' 페이지 테이블을 찾고 만약 페이지 테이블이 물리메모리에 존재하지 않는다면, 해당 명령어가 물리메모리에 존재하지 않으므로 프로그램이 저장된 저장장치에서 명령어가 위치한 영역을 메모리로 로드하여 해당 명령어의 물리 주소를 알려준다.
    </div>
    <div style="width: 40%; display: flex; justify-content: center; align-items: center;">
        <img src="https://github.com/revenge1005/WEB-Server-3-Tier-Architecture/assets/42735894/5d0ad859-e37f-43d3-abf1-a887cc5bfffc" alt="MMU_principle_updated" style="width: 100%;">
    </div>
</div>

<br>

<big> **■ 페이지 테이블** </big> <br>

페이지 테이블은 가상 메모리 시스템에서 가상 주소를 물리 주소로 매핑하는 데 사용되는 데이터 구조로 페이지 테이블은 메모리를 '페이지'라고 하는 일정한 크기의 블록으로 나누고, 각 페이지에 대한 정보(위치 정보, 로드 상태, 접근 권한 등)를 저장한다. <br><br>

<div style="display: flex; justify-content: space-between;">
    <div style="width: 60%; padding-right: 10px;">
        설명의 편의를 위해 32비트 주소 체계를 가진 컴퓨터를 생각해보자, 32비트 컴퓨터는 2^32개의 주소를 지정할 수 있다. (32비트 가상 주소는 10비트, 10비트, 12비트로 분할되어 있다.) <br><br> 1. 상위 10비트<br>: 페이지 디렉터리를 가리키며, 페이지 디렉터리는 2^10개의 엔트리를 저장할 수 있다. 이 각각의 엔트리는 페이지 테이블을 가리키는 역할을 한다. <br> 2. 중간 10비트<br>: 페이지 테이블 내의 특정 위치를 나타낸다. 즉, 페이지 테이블 베이스 주소로부터 얼마나 떨어져 있는지를 표현하는 오프셋입니다. 이 역시 2^10개의 독립된 위치를 가리킬 수 있다. <br> 3. 마지막 12비트<br>: 메모리 페이지 내에서의 정확한 위치를 나타낸다. 이 12비트는 2^12개의 엔트리를 가리킬 수 있으며, 이 각각의 엔트리는 바이트 단위로 실제 메모리 페이지 내의 위치를 결정한다. 
    </div>
    <div style="width: 40%; display: flex; justify-content: center; align-items: center;">
        <img src="https://github.com/revenge1005/Vagrant_study/assets/42735894/f881f675-fc87-4cf7-8311-a71be195ee69" alt="page_table" style="width: 100%;">
    </div>
</div>

<br>

<big> **■ 가상화 환경에서 메모리 변환** </big> <br>

가상머신에서도 동일한 '가상 주소 체계'를 사용할 것으로 보이지만, 가상머신은 물리시스템이 아니기 때문에 가상머신에서 사용하는 주소는 다시 물리시스템의 실제 메모리 주소에 매핑되어야 한다.

| 구분 | 메모리 주소 변환 과정 |
| :---: | :--- |
| 일반 환경(비가상화 환경) | 가상 주소 -> 물리 주소 |
| 가상 환경 | 1) 가상 주소 -> **'물리 주소'** -> 머신 주소 <br> 2) 가상 주소 -> **'가상 물리 주소'** -> 물리 주소 |

가상머신도 물리시스템과 동일하게 가상 주소에서 물리 주소로 변환하지만, <U>가상머신 또한 하이퍼바이저상에서 동작하는 하나의 프로세스이므로 물리 주소를 사용하지 않고 가상 주소를 사용</U>한다.

가상 환경에서의 주소 변환 과정 첫 번째 방법은 요청하는 과정 중에 하이퍼바이저가 실제 물리머신의 머신 주소를 넘겨준다. (이 방식에서는 물리시스템의 주소는 머신 주소가 되는 것이다.) 두 번째 방법은 가상 주소는 가상머신에서 사용하고 가상머신이 사용하는 물리 주소를 '가상물리 주소'라고 표현하다. 가상물리 주소를 하이퍼바이저에 의해 실제 물리머신의 주소로 변환한다.

<U>전가상화 환경의 게스트 OS는 자신이 가상환경에서 동작하고 있음을 인지하지 못하기 때문</U>에 물리시스템에서와 동일하게 <U>가상머신에서 동작하는 프로세스는 가상 주소를 사용하고 물리 주소를 직접 접근</U>하려고 할 것이다. 하지만, 가상머신 또한 하이퍼바이저 상에서 동작하는 프로세스이기 때문에 물리 주소는 실제 주소가 아니다. <U>따라서 하이퍼바이저가 가상머신이 사용할 수 있는 실질적인 물리 주소를 변환해주는 중재자 역할을 해야 한다.</U>

<br>

<big> **■ TLB 에뮬레이션 방식 메모리 가상화** </big> <br>

> 가상화 환경에서 메모리를 가상화한다는 것은 물리시스템의 주소 체계인 가상 주소와 물리 주소 간 매핑을 해주는 기능을 가상화해야 한다. 즉, MMU의 역항을 가상화해야 하는 것으로 볼 수 있다.

<div style="display: flex; justify-content: space-between;">
    <div style="width: 60%; padding-right: 10px;">
        【비가상화 환경에서 주소 변환하는 과정】은 CPU로부터 가상 주소에 대한 물리 주소를 요청받으면 TLB를 통해 해당 가상 주소에 매핑되는 물리 주소가 TLB에 존재하는지 확인한다. <br><br>(1) TLB에 정보가 존재한다면, TLB로부터 해당 물리 주소가 반환되며 만약 정보가 TLB에 존재하지 않는다면, 'TLB 미스 발생(프로세스의 페이지 테이블을 이용해 가상 주소에 매핑되는 물리 주소를 반환하고 동시에 TLB에 저장함)'한다. <br><br>(2) 만약 프로세스의 페이지 테이블에 해당 페이지가 물리메모리에 로드되지 않았을 경우에는 '페이지 폴트'를 발생시켜 OS가 페이지 폴트 핸들러를 통해서 해당 페이지가 메모리에 적재되도록 한다. <br><br>(3) 페이지 폴트가 되면, 페이지 폴트가 나게 된 명령을 중지시키고 OS의 페이지 폴트 핸들러에 의해서 명령수행에 필요한 페이지를 물리메모리에 적재시킨다. 가상 주소에 해당되는 물리 페이지가 메모리에 적재되었으므로, TLB 캐시에 매핑되는 관계를 적용 시킨다. <br><br>(4~5) 페이지 폴트가 났을 때 중지시켰던 명령을 다시 수행키면 해당 가상 주소는 이미 TLB에 적용되어 있기 때문에 TLB에서 물리 주소가 전달된다.
    </div>
    <div style="width: 40%; display: flex; justify-content: center; align-items: center;">
        <img src="https://github.com/revenge1005/kubernetes_build_ansible_playbook/assets/42735894/4c341c85-0111-4927-947f-a529c49f41ae" alt="address_translation" style="width: 100%;">
    </div>
</div>

<br>

> 비가상화 환경에서 MMU의 TLB에는 가상 주소와 가상 물리 주소 간 매핑 정보를 가지고 있으며, 만약 가상화 환경의 가상머신에서 사용하는 가상 주소, 물리 주소 간 매핑을 실제 머신 주소로 변환하는 작업을 수행해야 한다면 TLB에는 가상 주소와 머신 주소 간 매핑 정보를 가지고 있어야 한다. <br><br>하지만, 가상 주소를 바로 머신 주소로 매핑할 수 없고 가상 주소에서 가상물리 주소, 가상물리 주소에서 머신 주소 간 매핑 정보를 유지해야 한다. 이를 위해서 가상머신별로 TLB 에뮬레이션 페이지 테이블을 사용하는 에뮬레이션 TLB 방식을 사용한다.

![12321312](https://github.com/revenge1005/kubernetes_build_ansible_playbook/assets/42735894/3626eba2-1353-43df-b56f-a28825f72271){: width="90%" height="90%"}{: .align-center}

⑴ 가상머신에서 CPU가 접근하려는 가상 주소의 머신 주소를 TLB에서 찾는다. 만약 'TLB 미스(매핑 정보가 없음)'가 발생하면, 'TLB 에뮬레이션 페이지 테이블'에서 해당 가상 주소와 머신 주소의 매핑 정보를 찾는 과정으로 이어지고 매핑 정보가 있다면 TLB에 전달되고 중지된 프로세스를 재실행된다.

⑵ 만약 'TLB 에뮬레이션 페이지 테이블'에도 해당 매핑 정보가 없다면, '페이지 폴트'가 발생하게 되며, 이를 처리하기 위해 하이퍼바이저가 개입한다. '게스트 페이지 테이블'에서 해당 매핑 정보가 있는지 확인하고, 존재한다면 이 매핑 정보를 'TLB 에뮬레이션 페이지 테이불'과 TLB에 매핑 정보를 저장하고 중지된 프로세스를 재실행 시킨다.

> 'TLB 에뮬레이션 페이지 테이블'에는 존재하지 않은 가상 주소와 머신 주소의 매핑 정보가 '게스트 페이지 테이블'에 존재하는 이유는 'TLB 에뮬레이션 페이지 테이블'이 가상머신별로 존재하기 때문에 가상머신에서 동작하는 프로세스 간 콘텍스트 스위칭에 의해서 'TLB 에뮬레이션 페이지 테이블'의 정보가 매번 비워졌다 채워지기 때문이다. (즉, 이 경우 발생하는 페이지 폴트는 가상화 환경에서만 발생하는 특수한 경우로, 비가상화 환경에서 발생하지 않으며 이러한 페이지 폴트를 '히든 페이지 폴트'라고 한다.)

⑶ 만약 '게스트 페이지 테이블'에서도 매핑 정보를 찾지 못한다면, 이는 페이지가 메모리에 적재되지 않았음을 의미하며, 다시 페이지 폴트가 발생한다. 이 경우, 가상머신의 가상물리페이지와 머신페이지 매핑을 관리하는 PMap을 검색하고 매핑 정보가 존재한다면, 이를 'TLB 에뮬레이션 페이지 테이블'에 저장하고 TLB에서 새롭게 매핑된 주소를 사용할 수 있도록 한다. (여기서 발생하는 페이지 폴트를 '트루 페이지 폴트'라고 하며, 비가상화 환경에서도 발생한다.)

<br>

<big> **■ 섀도 페이지 테이블 방식 메모리 가상화** </big> <br>

TLB 에뮬레이션 방식은 'TLB 에뮬레이션 페이지 테이블'이 가상머신에 하나만 존재하기 때문에 콘텍스트 스위칭이 발생할 때마다, 가상머신의 'TLB 에뮬레이션 페이지 테이블'과 '게스트 페이지 테이블' 간 불일치로 많은 페이지 볼트가 발생한다. 이 문제를 해결하기 위한 방안으로 '섀도 페이지 테이블 방식'이다. 이 방식은 각 프로세스가 자신만의 'TLB 에뮬레이션 페이지 테이블'을 가지게 함으로써 히든 페이지 폴트를 줄이고 성능을 향상시키는 것을 목표로 한다.

![aadw](https://github.com/revenge1005/WEB-Server-3-Tier-Architecture/assets/42735894/a182fa4b-e05e-4269-950c-2766ae612c89){: width="90%" height="90%"}{: .align-center}

> 게스트 OS에서 동작하는 프로세스 1의 페이지 테이블을 보면, 가상 주소 20은 가상 물리 주소 15에 매핑되어 있고 가상 물리 주소 15는 실제 머신 주소 10에 매핑되므로 프로세스 1의 섀도 페이지 테이블에는 가상 주소 20에 매핑되는 머신 주소는 10이 엔트리로 들어 있게 된다. 


이렇게 구성된 섀도 페이지 테이블 방식은 게스트 OS 상의 프로세스 간 콘텐스트 스위칭이 발생할 때 섀도 페이지 테이블만 변경하게 되므로 TLB 애뮬레이션 페이지 테이블을 비울 필요가 없게 되어 히든 페이지 폴트도 발생하지 않는다.

하이퍼바이저가 섀도 페이지 테이블을 관리함으로써 가상머신이 자신이 실제 물리머신의 메모리를 접근하고 있다고 생각하게 만든다. 하이퍼바이저는 섀도 페이지 테이블에 게스트 페이지와 머신 페이지를 일대일로 매핑한다. 만약 게스트 페이지 테이블에 수정이 발생(가상 주소 -> 가상 물리 주소)하면 하이퍼바이저는 가상 주소에 해당하는 머신 주소를 섀도 페이지 테이블에 반영한다.